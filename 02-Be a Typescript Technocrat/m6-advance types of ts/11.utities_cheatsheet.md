 These are built-in types that let you transform or manipulate other types in very powerful ways. They‚Äôre super useful for making your code safer and more flexible. Let‚Äôs break it down clearly with examples.

---

### **1. `Partial<T>`**

Makes all properties in `T` optional.

```ts
interface User {
  id: number;
  name: string;
  email: string;
}

const updateUser: Partial<User> = {
  name: "Azizul" // can update only a subset of properties
};
```

---

### **2. `Required<T>`**

Makes all properties required.

```ts
interface User {
  id?: number;
  name?: string;
}

const newUser: Required<User> = {
  id: 1,
  name: "Azizul"
};
```

---

### **3. `Readonly<T>`**

Makes all properties read-only (cannot be reassigned).

```ts
const user: Readonly<User> = {
  id: 1,
  name: "Azizul"
};

// user.name = "New Name"; // ‚ùå Error
```

---

### **4. `Record<K, T>`**

Creates an object type with keys `K` and values `T`.

```ts
type Roles = "admin" | "user" | "guest";

const userRoles: Record<Roles, string> = {
  admin: "Azizul",
  user: "John",
  guest: "Doe"
};
```

---

### **5. `Pick<T, K>`**

Selects a subset of properties from `T`.

```ts
type UserPreview = Pick<User, "id" | "name">;

const userPreview: UserPreview = {
  id: 1,
  name: "Azizul"
};
```

---

### **6. `Omit<T, K>`**

Opposite of `Pick`. Excludes properties `K` from `T`.

```ts
type UserWithoutEmail = Omit<User, "email">;

const userWithoutEmail: UserWithoutEmail = {
  id: 1,
  name: "Azizul"
};
```

---

### **7. `Exclude<T, U>`**

Excludes types from a union.

```ts
type Status = "success" | "error" | "loading";
type NonLoading = Exclude<Status, "loading">; // "success" | "error"
```

---

### **8. `Extract<T, U>`**

Extracts types from a union that are assignable to `U`.

```ts
type Status = "success" | "error" | "loading";
type OnlyError = Extract<Status, "error" | "loading">; // "error" | "loading"
```

---

### **9. `NonNullable<T>`**

Removes `null` and `undefined` from a type.

```ts
type MaybeString = string | null | undefined;
type ActualString = NonNullable<MaybeString>; // string
```

---

### **10. `ReturnType<T>`**

Gets the return type of a function.

```ts
function getUser() {
  return { id: 1, name: "Azizul" };
}

type UserType = ReturnType<typeof getUser>; // { id: number, name: string }
```

---

### **11. `Parameters<T>`**

Gets the parameter types of a function as a tuple.

```ts
function add(a: number, b: number) {
  return a + b;
}

type AddParams = Parameters<typeof add>; // [number, number]
```

---

### **12. `InstanceType<T>`**

Gets the instance type of a class.

```ts
class Person {
  constructor(public name: string, public age: number) {}
}

type PersonInstance = InstanceType<typeof Person>; // Person
```

---

üí° **Tip:** These utility types are like TypeScript‚Äôs **built-in type operators**. They save you tons of time instead of manually creating new types for transformations.

---

If you want, I can make a **one-page ‚ÄúGod-tier cheat sheet‚Äù** for **all TS utility types** with examples‚Äîso you can just memorize it and never forget.

Do you want me to do that?

Haa bro, exactly!
**Utility types = TypeScript-er built-in type transformer** ‚Äî mane onno kono type alias/interface ke **super easy way te transform** korar ready-made tools.

Eta basically **type-level transformer toolkit**.
Cholo ekdom crystal-clear example diye bujhai ‚Üì

---

## üî• **1. Structural Transformer (Shape change)**

### **`Partial<T>` ‚Üí All props optional**

```ts
type User = { id: number; name: string };

type U1 = Partial<User>;
// { id?: number; name?: string }
```

### **`Required<T>` ‚Üí All props required**

```ts
type U2 = Required<Partial<User>>;
// { id: number; name: string }
```

### **`Readonly<T>` ‚Üí Freeze properties**

```ts
type U3 = Readonly<User>;
```

---

## üî• **2. Pick/Omit Transformer**

Type theke nirdisto property **tule neowa** ba **baad deowa**.

### **`Pick<T, Keys>`**

```ts
type JustName = Pick<User, "name">;
```

### **`Omit<T, Keys>`**

```ts
type WithoutName = Omit<User, "name">;
```

---

## üî• **3. Union Transformer**

Union types manipulate korar jonne powerful tools.

### **`Exclude<T, U>` ‚Üí U gula bad deowa**

```ts
type Status = "ok" | "error" | "loading";

type Clean = Exclude<Status, "loading">;
// "ok" | "error"
```

### **`Extract<T, U>` ‚Üí sudhu match gulo niye asha**

```ts
type ErrOnly = Extract<Status, "error" | "loading">;
// "error" | "loading"
```

---

## üî• **4. Function Transformer**

Function signature theke type ber kore.

### **`ReturnType<T>`**

```ts
function makeUser() {
  return { id: 1, name: "Azizul" };
}
type R = ReturnType<typeof makeUser>;
```

### **`Parameters<T>`**

```ts
function sum(a: number, b: number) { return a + b; }
type P = Parameters<typeof sum>; // [number, number]
```

---

## üî• **5. Key Transformer**

### **`Record<K, T>` ‚Üí Keys + Value Type**

```ts
type Roles = "admin" | "user";
type R = Record<Roles, number>;
// { admin: number; user: number }
```

---

## üéØ So yes‚ÄîUtility types = **Type Transformer shortcuts**

You write less, TypeScript does the transformation for you.
Eta mane sudhu ‚Äúshortcut‚Äù na ‚Äî **type-level functional programming**.
 