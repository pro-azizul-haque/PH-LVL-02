## Important Insight (Golden Rule ‚ú®)

‚úÖ Mapped types ‡¶∏‡¶¨‡¶∏‡¶Æ‡ßü union-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ iterate ‡¶ï‡¶∞‡ßá

‚ùå Object-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ direct loop ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ

keyof object ‚Üí union ‡¶¨‡¶æ‡¶®‡¶æ‡ßü

‡¶§‡¶æ‡¶∞‡¶™‡¶∞ mapped type ‚Üí union-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ loop ‡¶ö‡¶æ‡¶≤‡¶æ‡ßü

---

# ‚≠ê What is a *Mapped Type*?

Mapped Type ‡¶Æ‡¶æ‡¶®‡ßá:
**‡¶è‡¶ï‡¶ü‡¶æ existing type-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ loop ‡¶ï‡¶∞‡ßá ‡¶®‡¶§‡ßÅ‡¶® type ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã‡•§**
Exactly like:

> ‚ÄúType-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ `for...in` loop.‚Äù

---

# ‚≠ê Basic Structure

```ts
type MyMapped<T> = {
  [K in keyof T]: T[K];
};
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá

* `keyof T` = T-‡¶è‡¶∞ ‡¶∏‡¶¨ keys
* `[K in keyof T]` = ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ key-‡¶ï‡ßá iterate ‡¶ï‡¶∞‡¶õ‡ßá
* `T[K]` = ‡¶∏‡ßá‡¶á key-‡¶è‡¶∞ original type

---

# ‚≠ê Example: Make all properties optional

```ts
type MyPartial<T> = {
  [K in keyof T]?: T[K];
};
```

Same as built-in `Partial<T>`.

---

# ‚≠ê Example: Make all properties readonly

```ts
type MyReadonly<T> = {
  [K in keyof T]: Readonly<T[K]>;
};
```

‡¶Ö‡¶•‡¶¨‡¶æ short form:

```ts
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K];
};
```

---

# ‚≠ê Example: Make all properties `string` type

```ts
type AllString<T> = {
  [K in keyof T]: string;
};
```

---

# ‚≠ê Example: Add prefix to key names (Advanced vibe)

```ts
type PrefixKeys<T, P extends string> = {
  [K in keyof T as `${P}${string & K}`]: T[K];
};

type User = { name: string; age: number };

type Prefixed = PrefixKeys<User, "user_">;

/*
  {
     user_name: string;
     user_age: number;
  }
*/
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßá‡¶ñ‡ßã:
`as` ‡¶¶‡¶ø‡ßü‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ key rename ‡¶ï‡¶∞‡¶õ‡¶ø‡•§

---

# ‚≠ê Example: Create a type where all properties are nullable

```ts
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};
```

---

# ‚≠ê Example: Make all properties optional + readonly at the same time

```ts
type ReadOnlyOptional<T> = {
  readonly [K in keyof T]?: T[K];
};
```

---

# ‚≠ê Mapped Types with Conditional Type (üî• God-tier)

```ts
type ToPrimitive<T> = {
  [K in keyof T]: T[K] extends object ? string : T[K];
};
```

Use case: Convert nested objects ‚Üí primitive version.

---

# ‚≠ê Create a DTO (like backend style)

Imagine backend sends:

```ts
type User = {
  id: number;
  name: string;
  age: number;
};
```

We want a DTO where everything is string:

```ts
type UserDTO = {
  [K in keyof User]: string;
};
```

---

# ‚≠ê Extremely Powerful: Filter keys (Key Remap)

```ts
type OnlyStringProps<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};

type X = {
  a: string;
  b: number;
  c: string;
};

type Result = OnlyStringProps<X>;
/*
{
  a: string;
  c: string;
}
*/
```

---

# ‚≠ê Summary (Easy Words)

* Mapped Types = loop over keys
* `in` = iterate
* `keyof` = keys ‡¶®‡ßá‡ßü
* `as` = key rename
* Right side = value type define
* 80% advanced TypeScript magic proceed from here

---

